<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Go WebSocket Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .message-own {
        background-color: #e3f2fd;
        align-self: flex-end;
      }
      .message-other {
        background-color: #f1f5f9;
        align-self: flex-start;
      }
      .status-message {
        background-color: #f3f4f6;
      }
      .toast {
        transition: opacity 0.3s ease, transform 0.3s ease;
      }
      .toast-hidden {
        opacity: 0;
        transform: translateY(-10px);
      }
      #messages,
      #status-log {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .typing-status {
        min-height: 1.5rem;
      }
      .spinner {
        border: 2px solid #e5e7eb;
        border-top: 2px solid #3b82f6;
        border-radius: 50%;
        width: 1.5rem;
        height: 1.5rem;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      @media (max-width: 640px) {
        #container {
          flex-direction: column;
        }
        #sidebar {
          width: 100%;
        }
      }
      .user-status-online {
        color: green;
        font-weight: bold;
      }
      .user-status-offline {
        color: gray;
      }
      .message-timestamp {
        font-size: 0.75rem;
        color: #6b7280;
        margin-top: 0.25rem;
      }
      .empty-chat {
        text-align: center;
        color: #6b7280;
        font-style: italic;
      }
      .error-input {
        border-color: #ef4444;
      }
      .button-loading::after {
        content: "";
        display: inline-block;
        border: 2px solid #ffffff;
        border-top: 2px solid transparent;
        border-radius: 50%;
        width: 1rem;
        height: 1rem;
        animation: spin 0.75s linear infinite;
        margin-left: 0.5rem;
      }
    </style>
  </head>
  <body class="bg-gray-100 font-sans text-gray-800">
    <div class="max-w-5xl mx-auto p-4 sm:p-6">
      <h1 class="text-2xl sm:text-3xl font-bold mb-6 text-center text-blue-600">
        Go WebSocket Chat
      </h1>
      <div
        id="toast"
        class="fixed top-4 right-4 bg-white shadow-lg rounded-lg p-4 max-w-sm toast toast-hidden"
        role="alert"
        aria-live="assertive"
      ></div>
      <div id="container" class="flex flex-col sm:flex-row gap-6">
        <div id="sidebar" class="w-full sm:w-80 bg-white rounded-lg shadow p-4">
          <h2 class="text-lg font-semibold mb-4">User Setup</h2>
          <div class="space-y-3">
            <div>
              <label for="username" class="block text-sm font-medium"
                >Username</label
              >
              <input
                id="username"
                class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., alice (3-20 alphanumeric characters)"
                maxlength="20"
                aria-describedby="username-error"
              />
              <div
                id="username-error"
                class="text-red-500 text-sm hidden"
              ></div>
            </div>
            <div id="auth-buttons" class="flex gap-2">
              <button
                id="registerUser"
                onclick="ChatApp.registerUser()"
                class="flex-1 bg-blue-500 text-white p-2 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-400"
                aria-label="Register with username"
              >
                Register
              </button>
              <button
                id="loginUser"
                onclick="ChatApp.loginUser()"
                class="flex-1 bg-blue-500 text-white p-2 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-400"
                aria-label="Login with username"
              >
                Login
              </button>
              <button
                id="logoutUser"
                onclick="ChatApp.logoutUser()"
                class="flex-1 bg-red-500 text-white p-2 rounded hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 hidden"
                aria-label="Logout"
              >
                Logout
              </button>
            </div>
          </div>
          <h2 class="text-lg font-semibold mt-6 mb-4">Status Log</h2>
          <div
            id="status-log"
            class="space-y-2 max-h-40 overflow-y-auto p-2 border rounded bg-gray-50"
            aria-live="polite"
          ></div>
          <h2 class="text-lg font-semibold mt-6 mb-4">All Users</h2>
          <div
            id="all-users"
            class="space-y-2 max-h-40 overflow-y-auto"
            aria-live="polite"
          ></div>
          <h2 class="text-lg font-semibold mt-6 mb-4">Your Groups</h2>
          <div
            id="groups"
            class="space-y-2 max-h-40 overflow-y-auto"
            aria-live="polite"
          ></div>
          <h2 class="text-lg font-semibold mt-6 mb-4">Create Group</h2>
          <div class="space-y-3">
            <div>
              <label for="groupName" class="block text-sm font-medium"
                >Group Name</label
              >
              <input
                id="groupName"
                class="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., Friends (3-50 characters)"
                maxlength="50"
                disabled
                aria-describedby="groupName-error"
              />
              <div
                id="groupName-error"
                class="text-red-500 text-sm hidden"
              ></div>
            </div>
            <button
              id="createGroup"
              onclick="ChatApp.createGroup()"
              class="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-400"
              disabled
              aria-label="Create group with name"
            >
              Create Group
            </button>
          </div>
        </div>
        <div id="main" class="flex-1 bg-white rounded-lg shadow p-4">
          <div
            id="chat-header"
            class="text-lg font-semibold mb-4 flex items-center"
          >
            <span>Chat</span>
            <span id="chat-context" class="ml-2 text-blue-600"></span>
            <span id="loading" class="ml-2 hidden spinner"></span>
          </div>
          <div class="mb-4">
            <label for="targetId" class="block text-sm font-medium"
              >Chat With (Username / Group ID)</label
            >
            <div class="flex items-center gap-2">
              <input
                id="targetId"
                class="flex-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., bob or group1"
                maxlength="50"
                disabled
                aria-describedby="targetId-error"
              />
              <label class="flex items-center gap-1">
                <input
                  type="checkbox"
                  id="isGroup"
                  class="h-4 w-4"
                  disabled
                  aria-label="Toggle group chat"
                />
                <span>Group Chat</span>
              </label>
            </div>
            <div id="targetId-error" class="text-red-500 text-sm hidden"></div>
          </div>
          <div
            id="group-management"
            class="mb-4 hidden transition-all duration-300"
          >
            <h3 class="text-md font-semibold mb-2">Group Management</h3>
            <div class="flex gap-2 mb-2">
              <input
                id="addMemberUsername"
                class="flex-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Username (e.g., bob)"
                maxlength="20"
                disabled
                aria-describedby="addMemberUsername-error"
              />
              <button
                id="addMember"
                onclick="ChatApp.addMember()"
                class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-400"
                disabled
                aria-label="Add member to group"
              >
                Add
              </button>
            </div>
            <div
              id="addMemberUsername-error"
              class="text-red-500 text-sm hidden"
            ></div>
            <div class="text-sm font-medium mb-2">Group Members</div>
            <div
              id="group-members"
              class="space-y-2 max-h-40 overflow-y-auto"
              aria-live="polite"
            ></div>
          </div>
          <div
            id="typing-status"
            class="text-sm text-gray-500 italic mb-2 typing-status"
            aria-live="polite"
          ></div>
          <div
            id="messages"
            class="h-96 overflow-y-auto p-4 border rounded bg-gray-50 mb-4"
            role="log"
            aria-live="polite"
          ></div>
          <div class="flex gap-2">
            <input
              id="messageInput"
              class="flex-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Type a message... (max 1000 characters)"
              maxlength="1000"
              disabled
              aria-describedby="messageInput-error"
            />
            <button
              id="sendMessage"
              onclick="ChatApp.sendMessage()"
              class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-400"
              disabled
              aria-label="Send message"
            >
              Send
            </button>
          </div>
          <div
            id="messageInput-error"
            class="text-red-500 text-sm hidden"
          ></div>
        </div>
      </div>
    </div>

    <script>
      const ChatApp = (function () {
        // Constants
        const API_BASE = "http://localhost:8080";
        const WS_BASE = "ws://localhost:8080/ws";
        const MAX_RECONNECT_ATTEMPTS = 3;
        const RECONNECT_INTERVAL = 5000;
        const USERNAME_REGEX = /^[a-z0-9]{3,20}$/;
        const GROUP_NAME_REGEX = /^[\w\s-]{3,50}$/;
        const ID_REGEX = /^[a-z0-9-]{1,50}$/;
        const MAX_MESSAGES = 1000;
        const TOAST_DURATION = 3000;
        const TYPING_TIMEOUT = 5000; // Timeout for typing status per user

        // State
        let state = {
          socket: null,
          username: null,
          targetId: null,
          currentGroup: null,
          isRegistered: false,
          isConnected: false,
          isProcessing: false,
          processingButtons: new Set(),
          reconnectAttempts: 0,
          displayedMessages: new Set(),
          allUsers: [],
          onlineUsers: new Set(),
          groups: [],
          typingTimeout: null,
          isTypingSent: false,
          typingUsers: new Map(), // Map to track users and their typing timeouts
        };

        // DOM Elements
        const elements = {
          toast: document.getElementById("toast"),
          username: document.getElementById("username"),
          registerUser: document.getElementById("registerUser"),
          loginUser: document.getElementById("loginUser"),
          logoutUser: document.getElementById("logoutUser"),
          groupName: document.getElementById("groupName"),
          createGroup: document.getElementById("createGroup"),
          targetId: document.getElementById("targetId"),
          isGroup: document.getElementById("isGroup"),
          addMemberUsername: document.getElementById("addMemberUsername"),
          addMember: document.getElementById("addMember"),
          messageInput: document.getElementById("messageInput"),
          sendMessage: document.getElementById("sendMessage"),
          messages: document.getElementById("messages"),
          statusLog: document.getElementById("status-log"),
          allUsers: document.getElementById("all-users"),
          groups: document.getElementById("groups"),
          groupMembers: document.getElementById("group-members"),
          chatContext: document.getElementById("chat-context"),
          typingStatus: document.getElementById("typing-status"),
          groupManagement: document.getElementById("group-management"),
          loading: document.getElementById("loading"),
        };

        // Utility Functions
        function debounce(func, wait) {
          let timeout;
          return function (...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), wait);
          };
        }

        function showToast(message, isError = false) {
          if (!message) return;
          elements.toast.textContent = message;
          elements.toast.className = `fixed top-4 right-4 bg-white shadow-lg rounded-lg p-4 max-w-sm toast ${
            isError
              ? "border-l-4 border-red-500"
              : "border-l-4 border-green-500"
          }`;
          elements.toast.setAttribute("aria-label", message);
          setTimeout(() => {
            elements.toast.className =
              "fixed top-4 right-4 bg-white shadow-lg rounded-lg p-4 max-w-sm toast toast-hidden";
            elements.toast.removeAttribute("aria-label");
          }, TOAST_DURATION);
        }

        function showError(elementId, message) {
          const errorEl = document.getElementById(`${elementId}-error`);
          errorEl.textContent = message;
          errorEl.classList.remove("hidden");
          document.getElementById(elementId).classList.add("error-input");
        }

        function clearError(elementId) {
          const errorEl = document.getElementById(`${elementId}-error`);
          errorEl.textContent = "";
          errorEl.classList.add("hidden");
          document.getElementById(elementId).classList.remove("error-input");
        }

        function sanitizeInput(input) {
          if (typeof input !== "string") return "";
          const div = document.createElement("div");
          div.textContent = input;
          return div.innerHTML;
        }

        function validateInput(input, regex, elementId, errorMessage) {
          if (!input) {
            showError(elementId, "Field cannot be empty");
            return false;
          }
          if (!regex.test(input)) {
            showError(elementId, errorMessage);
            return false;
          }
          clearError(elementId);
          return true;
        }

        // UI Updates
        function updateUIState() {
          const isSignedIn = state.isRegistered && state.isConnected;
          const usernameEntered = elements.username.value.trim();
          const targetSelected = elements.targetId.value.trim();
          const groupNameEntered = elements.groupName.value.trim();
          const addMemberEntered = elements.addMemberUsername.value.trim();
          const messageEntered = elements.messageInput.value.trim();

          elements.username.disabled = isSignedIn;
          elements.registerUser.disabled = isSignedIn || !usernameEntered;
          elements.loginUser.disabled = isSignedIn || !usernameEntered;
          elements.logoutUser.disabled = !isSignedIn;
          elements.registerUser.classList.toggle("hidden", isSignedIn);
          elements.loginUser.classList.toggle("hidden", isSignedIn);
          elements.logoutUser.classList.toggle("hidden", !isSignedIn);

          elements.groupName.disabled = !isSignedIn;
          elements.createGroup.disabled = !isSignedIn || !groupNameEntered;

          elements.targetId.disabled = !isSignedIn;
          elements.isGroup.disabled = !isSignedIn;

          elements.messageInput.disabled = !isSignedIn || !targetSelected;
          elements.sendMessage.disabled =
            !isSignedIn || !targetSelected || !messageEntered;

          elements.addMemberUsername.disabled =
            !isSignedIn || !state.currentGroup;
          elements.addMember.disabled =
            !isSignedIn || !state.currentGroup || !addMemberEntered;

          if (state.currentGroup) {
            updateGroupMembers();
          }
        }

        function appendMessage(content, id, className, timestamp) {
          if (!content) return;
          if (state.displayedMessages.size >= MAX_MESSAGES) {
            const oldest = elements.messages.firstChild;
            if (oldest && oldest.dataset.id) {
              state.displayedMessages.delete(oldest.dataset.id);
              oldest.remove();
            }
          }
          const msgDiv = document.createElement("div");
          msgDiv.className = `p-2 rounded text-sm ${className}`;
          msgDiv.innerHTML = `<div>${content}</div>${
            timestamp
              ? `<div class="message-timestamp">${sanitizeInput(
                  timestamp
                )}</div>`
              : ""
          }`;
          if (id) {
            msgDiv.dataset.id = id;
            state.displayedMessages.add(id);
          }
          elements.messages.appendChild(msgDiv);
          elements.messages.scrollTop = elements.messages.scrollHeight;
        }

        function appendStatusMessage(content, className) {
          if (!content) return;
          if (elements.statusLog.childElementCount >= MAX_MESSAGES) {
            elements.statusLog.firstChild.remove();
          }
          const statusDiv = document.createElement("div");
          statusDiv.className = `text-sm ${className}`;
          statusDiv.textContent = content;
          elements.statusLog.appendChild(statusDiv);
          elements.statusLog.scrollTop = elements.statusLog.scrollHeight;
        }

        // WebSocket Management
        async function connect() {
          if (!state.username) {
            showToast("Please log in or register first", true);
            return false;
          }
          if (state.socket && state.socket.readyState === WebSocket.OPEN) {
            state.socket.close();
          }

          try {
            state.socket = new WebSocket(
              `${WS_BASE}?username=${encodeURIComponent(state.username)}`
            );

            state.socket.onopen = async () => {
              state.isConnected = true;
              state.reconnectAttempts = 0;
              showToast("Connected to chat");
              appendStatusMessage(
                `Connected as ${state.username}`,
                "text-green-600"
              );
              await Promise.all([updateAllUsers(), updateGroups()]);
              updateUIState();
            };

            state.socket.onmessage = async (event) => {
              let msg;
              try {
                msg = JSON.parse(event.data);
                if (!msg || !msg.type)
                  throw new Error("Invalid message format");
                console.log("Received WebSocket message:", msg); // Debug log
              } catch (err) {
                console.error("Malformed WebSocket message:", event.data);
                return;
              }

              switch (msg.type) {
                case "message":
                  if (
                    msg.id &&
                    !state.displayedMessages.has(msg.id) &&
                    ((msg.group_id && msg.group_id === state.targetId) ||
                      (msg.sender === state.targetId && !msg.group_id) ||
                      (msg.receiver === state.targetId && !msg.group_id))
                  ) {
                    state.displayedMessages.add(msg.id);
                    const timestamp = msg.timestamp
                      ? new Date(msg.timestamp).toLocaleString()
                      : new Date().toLocaleString();
                    appendMessage(
                      `[${sanitizeInput(msg.sender)}] ${sanitizeInput(
                        msg.content
                      )}`,
                      msg.id,
                      msg.sender === state.username
                        ? "message-own"
                        : "message-other",
                      timestamp
                    );
                  }
                  break;
                case "typing":
                  console.log(
                    `Typing message: sender=${msg.sender}, status=${
                      msg.status
                    }, group_id=${msg.group_id || "none"}`
                  ); // Debug log
                  showTyping(msg.sender, msg.status === "start", msg.group_id);
                  break;
                case "status":
                  appendStatusMessage(
                    `${sanitizeInput(msg.sender)} is ${msg.status}`,
                    "text-gray-500"
                  );
                  if (msg.status === "online") {
                    state.onlineUsers.add(msg.sender);
                  } else {
                    state.onlineUsers.delete(msg.sender);
                  }
                  renderAllUsers();
                  break;
                case "group_update":
                  const { type: groupUpdateType, data: groupUpdateData } =
                    msg.data || {};
                  if (
                    msg.group_id &&
                    groupUpdateType &&
                    groupUpdateData &&
                    groupUpdateData.username
                  ) {
                    appendMessage(
                      `[GROUP/${sanitizeInput(msg.group_id)}] ${sanitizeInput(
                        groupUpdateType
                      )}: ${sanitizeInput(groupUpdateData.username)}`,
                      "",
                      "text-blue-600 status-message",
                      new Date().toLocaleString()
                    );
                    if (msg.group_id === state.currentGroup) {
                      if (
                        ["add", "kick", "add_admin", "remove_admin"].includes(
                          groupUpdateType
                        )
                      ) {
                        // Force immediate group member list refresh
                        await updateGroupMembers(true);
                      }
                      if (
                        groupUpdateType === "kick" &&
                        groupUpdateData.username === state.username
                      ) {
                        state.currentGroup = null;
                        state.targetId = null;
                        elements.targetId.value = "";
                        elements.isGroup.checked = false;
                        elements.groupManagement.classList.add("hidden");
                        elements.messages.innerHTML = "";
                        elements.typingUsers.clear();
                        elements.typingStatus.textContent = "";
                        elements.chatContext.textContent = "";
                        showToast(
                          `You were kicked from group ${msg.group_id}`,
                          true
                        );
                      }
                    }
                    await updateGroups();
                  }
                  break;
                case "error":
                  showToast(
                    `WebSocket Error: ${sanitizeInput(
                      msg.message || "Unknown error"
                    )}`,
                    true
                  );
                  break;
                default:
                  console.warn("Unknown message type:", msg.type);
              }
            };

            state.socket.onclose = () => {
              state.isConnected = false;
              appendStatusMessage("Disconnected", "text-red-600");
              showToast("Disconnected from chat", true);
              elements.groupManagement.classList.add("hidden");
              state.typingUsers.clear();
              elements.typingStatus.textContent = "";
              attemptReconnect();
              updateUIState();
            };

            state.socket.onerror = (error) => {
              console.error("WebSocket Error:", error);
              showToast("WebSocket connection error", true);
              state.isConnected = false;
              state.typingUsers.clear();
              elements.typingStatus.textContent = "";
              updateUIState();
            };

            return true;
          } catch (err) {
            showToast(`Failed to initiate WebSocket: ${err.message}`, true);
            return false;
          }
        }

        function attemptReconnect() {
          if (
            state.reconnectAttempts >= MAX_RECONNECT_ATTEMPTS ||
            !state.username
          ) {
            showToast(
              "Max reconnect attempts reached. Please log in again.",
              true
            );
            return;
          }
          state.reconnectAttempts++;
          showToast(
            `Reconnecting... (Attempt ${state.reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`
          );
          setTimeout(async () => {
            if (state.isConnected) return;
            await connect();
          }, RECONNECT_INTERVAL);
        }

        // API Calls
        async function registerUser() {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          state.isProcessing = true;
          updateUIState();

          const usernameInput = elements.username.value.trim().toLowerCase();
          if (
            !validateInput(
              usernameInput,
              USERNAME_REGEX,
              "username",
              "Username must be 3-20 alphanumeric characters"
            )
          ) {
            state.isProcessing = false;
            updateUIState();
            return;
          }
          state.username = usernameInput;

          try {
            const res = await fetch(`${API_BASE}/users`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ username: state.username }),
            });
            if (res.status === 409) {
              throw new Error("Username already exists. Try logging in.");
            }
            if (!res.ok) {
              const errorData = await res.json();
              throw new Error(
                errorData.error || `Failed to register (${res.status})`
              );
            }

            state.isRegistered = true;
            showToast(`Registered successfully as ${state.username}`);
            appendStatusMessage(
              `Registered as ${state.username}`,
              "text-green-600"
            );
            await Promise.all([updateAllUsers(), updateGroups()]);
          } catch (err) {
            state.username = null;
            showToast(`Registration failed: ${err.message}`, true);
          } finally {
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function loginUser() {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          state.isProcessing = true;
          updateUIState();

          const usernameInput = elements.username.value.trim().toLowerCase();
          if (
            !validateInput(
              usernameInput,
              USERNAME_REGEX,
              "username",
              "Username must be 3-20 alphanumeric characters"
            )
          ) {
            state.isProcessing = false;
            updateUIState();
            return;
          }
          state.username = usernameInput;

          try {
            const userRes = await fetch(
              `${API_BASE}/users/${encodeURIComponent(state.username)}`
            );
            if (!userRes.ok) {
              if (userRes.status === 404) {
                throw new Error("Username not found. Try registering.");
              }
              throw new Error(`Failed to verify user (${userRes.status})`);
            }

            state.isRegistered = true;
            await connect();
          } catch (err) {
            state.username = null;
            state.isRegistered = false;
            showToast(`Login failed: ${err.message}`, true);
          } finally {
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function logoutUser() {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          state.isProcessing = true;
          updateUIState();

          if (state.socket) {
            try {
              state.socket.close();
            } catch (err) {
              console.warn("Error closing WebSocket:", err);
            }
            state.socket = null;
          }

          state.isRegistered = false;
          state.isConnected = false;
          state.username = null;
          state.targetId = null;
          state.currentGroup = null;
          state.displayedMessages.clear();
          state.allUsers = [];
          state.onlineUsers.clear();
          state.groups = [];
          state.reconnectAttempts = 0;
          state.processingButtons.clear();
          state.typingUsers.clear();

          elements.username.value = "";
          elements.targetId.value = "";
          elements.groupName.value = "";
          elements.addMemberUsername.value = "";
          elements.messages.innerHTML = "";
          elements.statusLog.innerHTML = "";
          elements.allUsers.innerHTML = "";
          elements.groups.innerHTML = "";
          elements.groupMembers.innerHTML = "";
          elements.chatContext.textContent = "";
          elements.typingStatus.textContent = "";
          elements.groupManagement.classList.add("hidden");

          if (state.typingTimeout) {
            clearTimeout(state.typingTimeout);
            state.typingTimeout = null;
          }

          showToast("Logged out successfully");
          state.isProcessing = false;
          updateUIState();
        }

        async function createGroup() {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          state.isProcessing = true;
          updateUIState();

          const groupName = elements.groupName.value.trim();
          if (
            !validateInput(
              groupName,
              GROUP_NAME_REGEX,
              "groupName",
              "Group name must be 3-50 characters (alphanumeric, spaces, hyphens)"
            )
          ) {
            state.isProcessing = false;
            updateUIState();
            return;
          }
          if (!state.username || !state.isConnected) {
            state.isProcessing = false;
            updateUIState();
            return showToast("You must be logged in to create a group", true);
          }

          try {
            elements.createGroup.disabled = true;
            const res = await fetch(`${API_BASE}/groups`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name: groupName, owner: state.username }),
            });
            if (!res.ok) {
              const errorData = await res.json();
              throw new Error(
                errorData.error || `Failed to create group (${res.status})`
              );
            }
            const group = await res.json();
            appendStatusMessage(
              `Created group ${sanitizeInput(group.name)} (${group.id})`,
              "text-green-600"
            );
            await updateGroups();
            elements.groupName.value = "";
            showToast("Group created successfully");
          } catch (err) {
            showToast(`Failed to create group: ${err.message}`, true);
          } finally {
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function updateAllUsers() {
          try {
            const allRes = await fetch(`${API_BASE}/users`);
            if (!allRes.ok)
              throw new Error(`Failed to fetch users (${allRes.status})`);
            state.allUsers = await allRes.json();

            if (state.isConnected) {
              const onlineRes = await fetch(`${API_BASE}/users/online`);
              if (!onlineRes.ok)
                throw new Error(
                  `Failed to fetch online users (${onlineRes.status})`
                );
              const onlineUsers = await onlineRes.json();
              state.onlineUsers.clear();
              onlineUsers.forEach((u) => {
                if (u.username) state.onlineUsers.add(u.username);
              });
            } else {
              state.onlineUsers.clear();
            }

            renderAllUsers();
          } catch (err) {
            showToast(`Error fetching users: ${err.message}`, true);
            elements.allUsers.innerHTML = `<p class="text-red-500">Could not load users.</p>`;
          }
        }

        function renderAllUsers() {
          if (!state.allUsers.length) {
            elements.allUsers.innerHTML = "<p>No users found.</p>";
            return;
          }

          elements.allUsers.innerHTML = state.allUsers
            .filter((u) => u.username)
            .map((u) => {
              const isOnline = state.onlineUsers.has(u.username);
              const statusClass = isOnline
                ? "user-status-online"
                : "user-status-offline";
              const statusText = isOnline ? "Online" : "Offline";
              const chatButton =
                u.username !== state.username
                  ? `<button onclick="ChatApp.startChat('${sanitizeInput(
                      u.username
                    )}', false)" class="bg-blue-500 text-white px-2 py-1 rounded text-xs hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                      !state.isConnected ? "hidden" : ""
                    }" ${
                      !state.isConnected ? "disabled" : ""
                    } aria-label="Chat with ${u.username}">Chat</button>`
                  : "(You)";

              return `
                <div class="flex items-center justify-between p-1 hover:bg-gray-100 rounded text-sm">
                  <span>
                    ${sanitizeInput(
                      u.username
                    )} <span class="${statusClass}">(${statusText})</span>
                  </span>
                  ${chatButton}
                </div>
              `;
            })
            .join("");
        }

        async function updateGroups() {
          if (!state.username || !state.isRegistered) {
            elements.groups.innerHTML = "";
            return;
          }

          try {
            const res = await fetch(
              `${API_BASE}/users/${encodeURIComponent(state.username)}/groups`
            );
            if (!res.ok) {
              if (res.status === 404) {
                elements.groups.innerHTML = "<p>No groups joined.</p>";
                return;
              }
              throw new Error(`Failed to fetch groups (${res.status})`);
            }
            state.groups = await res.json();
            if (!state.groups.length) {
              elements.groups.innerHTML = "<p>No groups joined.</p>";
              return;
            }

            elements.groups.innerHTML = state.groups
              .filter((g) => g.id && g.name)
              .map(
                (g) => `
                <div class="flex items-center justify-between p-2 hover:bg-gray-100 rounded">
                  <span>${sanitizeInput(g.name)} (${sanitizeInput(g.id)})</span>
                  <button onclick="ChatApp.joinGroup('${sanitizeInput(
                    g.id
                  )}')" class="bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                  !state.isConnected ? "hidden" : ""
                }" ${
                  !state.isConnected ? "disabled" : ""
                } aria-label="Join group ${g.name}">Chat</button>
                </div>
              `
              )
              .join("");
          } catch (err) {
            showToast(`Error fetching groups: ${err.message}`, true);
            elements.groups.innerHTML = `<p class="text-red-500">Could not load groups.</p>`;
          }
        }

        async function joinGroup(groupId) {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          if (!state.isConnected)
            return showToast("Login first to join a group", true);
          if (
            !validateInput(
              groupId,
              ID_REGEX,
              "targetId",
              "Group ID must be 1-50 alphanumeric characters or hyphens"
            )
          ) {
            return;
          }

          state.isProcessing = true;
          updateUIState();

          try {
            const res = await fetch(
              `${API_BASE}/groups/${encodeURIComponent(groupId)}`
            );
            if (!res.ok) {
              if (res.status === 404) throw new Error("Group not found");
              if (res.status === 403) throw new Error("Access to group denied");
              throw new Error(`Failed to fetch group details (${res.status})`);
            }
            const group = await res.json();
            if (!group.id || !group.name || !Array.isArray(group.members)) {
              throw new Error("Invalid group data received");
            }
            if (!group.members.includes(state.username)) {
              throw new Error("You are not a member of this group");
            }

            if (state.socket && state.socket.readyState === WebSocket.OPEN) {
              state.socket.send(
                JSON.stringify({
                  type: "join_group",
                  sender: state.username,
                  group_id: groupId,
                })
              );
            } else {
              throw new Error("WebSocket not connected");
            }

            state.currentGroup = groupId;
            state.targetId = groupId;
            elements.targetId.value = groupId;
            elements.isGroup.checked = true;
            elements.groupManagement.classList.remove("hidden");
            state.displayedMessages.clear();
            state.typingUsers.clear();
            elements.messages.innerHTML = "";
            elements.typingStatus.textContent = "";

            await updateChatHeader(groupId, true);
            await loadMessageHistory(groupId, true);
            await updateGroupMembers();

            appendStatusMessage(
              `Joined group chat ${sanitizeInput(group.name)} (${sanitizeInput(
                groupId
              )})`,
              "text-blue-600"
            );
            showToast(`Joined group ${sanitizeInput(group.name)}`);
          } catch (err) {
            showToast(`Failed to join group: ${err.message}`, true);
            elements.groupManagement.classList.add("hidden");
          } finally {
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function updateGroupMembers(forceRefresh = false) {
          if (!state.currentGroup || !state.isConnected) {
            elements.groupMembers.innerHTML = "";
            return;
          }

          try {
            // Show loading indicator
            elements.loading.classList.remove("hidden");

            const res = await fetch(
              `${API_BASE}/groups/${encodeURIComponent(state.currentGroup)}`
            );
            if (!res.ok) {
              if (res.status === 404) throw new Error("Group not found");
              throw new Error(`Failed to fetch group details (${res.status})`);
            }
            const group = await res.json();
            const isOwner = group.owner === state.username;
            const isAdmin =
              group.admins && group.admins.includes(state.username);
            const memberUsernames = group.members || [];
            const adminUsernames = new Set(group.admins || []);

            if (!memberUsernames.length) {
              elements.groupMembers.innerHTML = "<p>No members in group.</p>";
              return;
            }

            elements.groupMembers.innerHTML = memberUsernames
              .filter((m) => m)
              .map((memberUsername) => {
                const memberIsAdmin = adminUsernames.has(memberUsername);
                const memberIsOwner = memberUsername === group.owner;
                const showKick =
                  (isOwner || isAdmin) &&
                  memberUsername !== state.username &&
                  !memberIsOwner;
                const showAdminToggle =
                  isOwner &&
                  memberUsername !== state.username &&
                  !memberIsOwner;
                const buttonKey = `${memberUsername}-${
                  showKick ? "kick" : ""
                }-${
                  showAdminToggle
                    ? memberIsAdmin
                      ? "removeAdmin"
                      : "addAdmin"
                    : ""
                }`;

                return `
                  <div class="flex items-center justify-between p-1 hover:bg-gray-100 rounded text-sm">
                    <span>
                      ${sanitizeInput(memberUsername)}
                      ${memberIsAdmin ? " (Admin)" : ""}
                      ${memberIsOwner ? " (Owner)" : ""}
                    </span>
                    <div class="space-x-1">
                      ${
                        showKick
                          ? `<button onclick="ChatApp.kickMember('${sanitizeInput(
                              memberUsername
                            )}')" class="bg-red-500 text-white px-1 py-0.5 rounded text-xs hover:bg-red-600 focus:outline-none focus:ring-1 focus:ring-red-500 ${
                              state.processingButtons.has(buttonKey)
                                ? "button-loading"
                                : ""
                            }" ${
                              state.processingButtons.has(buttonKey)
                                ? "disabled"
                                : ""
                            } aria-label="Kick ${memberUsername} from group">Kick</button>`
                          : ""
                      }
                      ${
                        showAdminToggle
                          ? memberIsAdmin
                            ? `<button onclick="ChatApp.removeAdmin('${sanitizeInput(
                                memberUsername
                              )}')" class="bg-yellow-500 text-white px-1 py-0.5 rounded text-xs hover:bg-yellow-600 focus:outline-none focus:ring-1 focus:ring-yellow-500 ${
                                state.processingButtons.has(buttonKey)
                                  ? "button-loading"
                                  : ""
                              }" ${
                                state.processingButtons.has(buttonKey)
                                  ? "disabled"
                                  : ""
                              } aria-label="Remove admin status from ${memberUsername}">Remove Admin</button>`
                            : `<button onclick="ChatApp.addAdmin('${sanitizeInput(
                                memberUsername
                              )}')" class="bg-green-500 text-white px-1 py-0.5 rounded text-xs hover:bg-green-600 focus:outline-none focus:ring-1 focus:ring-green-500 ${
                                state.processingButtons.has(buttonKey)
                                  ? "button-loading"
                                  : ""
                              }" ${
                                state.processingButtons.has(buttonKey)
                                  ? "disabled"
                                  : ""
                              } aria-label="Make ${memberUsername} admin">Make Admin</button>`
                          : ""
                      }
                    </div>
                  </div>
                `;
              })
              .join("");
          } catch (err) {
            showToast(`Error fetching group members: ${err.message}`, true);
            elements.groupMembers.innerHTML = `<p class="text-red-500">Could not load members.</p>`;
          } finally {
            elements.loading.classList.add("hidden");
          }
        }

        async function startChat(targetUsername, isGroup) {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          if (!state.isConnected)
            return showToast("Login first to start a chat", true);
          if (
            !validateInput(
              targetUsername,
              ID_REGEX,
              "targetId",
              "Target ID must be 1-50 alphanumeric characters or hyphens"
            )
          ) {
            return;
          }
          if (
            !isGroup &&
            targetUsername.toLowerCase() === state.username.toLowerCase()
          ) {
            return showToast("Cannot chat with yourself", true);
          }

          state.isProcessing = true;
          updateUIState();

          try {
            if (isGroup) {
              await joinGroup(targetUsername);
            } else {
              const res = await fetch(
                `${API_BASE}/users/${encodeURIComponent(targetUsername)}`
              );
              if (!res.ok) {
                if (res.status === 404) throw new Error("User not found");
                throw new Error(`Failed to verify user (${res.status})`);
              }

              state.targetId = targetUsername;
              state.currentGroup = null;
              elements.targetId.value = targetUsername;
              elements.isGroup.checked = false;
              elements.groupManagement.classList.add("hidden");
              state.displayedMessages.clear();
              state.typingUsers.clear();
              elements.messages.innerHTML = "";
              elements.typingStatus.textContent = "";

              appendStatusMessage(
                `Started chat with ${sanitizeInput(targetUsername)}`,
                "text-blue-600"
              );
              await loadMessageHistory(targetUsername, false);
              await updateChatHeader(targetUsername, false);
            }
          } catch (err) {
            showToast(`Failed to start chat: ${err.message}`, true);
          } finally {
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function updateChatHeader(id, isGroup) {
          try {
            if (isGroup) {
              const res = await fetch(
                `${API_BASE}/groups/${encodeURIComponent(id)}`
              );
              if (!res.ok) {
                if (res.status === 404) throw new Error("Group not found");
                throw new Error(`Failed to fetch group (${res.status})`);
              }
              const group = await res.json();
              elements.chatContext.textContent = `(Group: ${sanitizeInput(
                group.name || id
              )})`;
            } else {
              elements.chatContext.textContent = `(User: ${sanitizeInput(id)})`;
            }
          } catch (err) {
            showToast(`Error updating chat header: ${err.message}`, true);
            elements.chatContext.textContent = `(ID: ${sanitizeInput(id)})`;
          }
        }

        async function loadMessageHistory(id, isGroup) {
          elements.loading.classList.remove("hidden");
          try {
            const url = isGroup
              ? `${API_BASE}/groups/${encodeURIComponent(id)}/messages`
              : `${API_BASE}/users/${encodeURIComponent(
                  state.username
                )}/messages/${encodeURIComponent(id)}`;
            const res = await fetch(url);
            if (!res.ok) {
              if (res.status === 404) {
                throw new Error(isGroup ? "Group not found" : "Chat not found");
              }
              throw new Error(
                `Failed to fetch message history (${res.status})`
              );
            }
            const messages = await res.json();
            state.displayedMessages.clear();
            elements.messages.innerHTML = "";

            if (!messages || messages.length === 0) {
              appendMessage("No messages yet.", "", "empty-chat", "");
            } else {
              messages.forEach((msg) => {
                if (msg.id && !state.displayedMessages.has(msg.id)) {
                  state.displayedMessages.add(msg.id);
                  const timestamp = msg.timestamp
                    ? isNaN(Date.parse(msg.timestamp))
                      ? new Date().toLocaleString()
                      : new Date(msg.timestamp).toLocaleString()
                    : new Date().toLocaleString();
                  appendMessage(
                    `[${sanitizeInput(msg.sender)}] ${sanitizeInput(
                      msg.content
                    )}`,
                    msg.id,
                    msg.sender === state.username
                      ? "message-own"
                      : "message-other",
                    timestamp
                  );
                }
              });
            }
          } catch (err) {
            showToast(`Error loading message history: ${err.message}`, true);
            appendMessage("Failed to load messages.", "", "empty-chat", "");
          } finally {
            elements.loading.classList.add("hidden");
          }
        }

        async function addMember() {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          if (!state.isConnected)
            return showToast("Not connected to chat", true);
          if (!state.currentGroup) return showToast("No group selected", true);

          const username = elements.addMemberUsername.value
            .trim()
            .toLowerCase();
          if (
            !validateInput(
              username,
              USERNAME_REGEX,
              "addMemberUsername",
              "Username must be 3-20 alphanumeric characters"
            )
          ) {
            return;
          }
          if (username === state.username) {
            showError("addMemberUsername", "Cannot add yourself");
            return;
          }

          state.isProcessing = true;
          updateUIState();

          try {
            const res = await fetch(
              `${API_BASE}/groups/${encodeURIComponent(
                state.currentGroup
              )}/members`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  username: username,
                  requester: state.username,
                }),
              }
            );
            if (!res.ok) {
              const errorData = await res.json();
              throw new Error(
                errorData.error || `Failed to add member (${res.status})`
              );
            }
            elements.addMemberUsername.value = "";
            showToast(`Added ${sanitizeInput(username)} to group`);
            // Group member list will be updated via WebSocket group_update
          } catch (err) {
            showToast(`Failed to add member: ${err.message}`, true);
          } finally {
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function kickMember(username) {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          if (!state.isConnected)
            return showToast("Not connected to chat", true);
          if (!state.currentGroup) return showToast("No group selected", true);
          if (
            !validateInput(
              username,
              USERNAME_REGEX,
              "addMemberUsername",
              "Invalid username"
            )
          ) {
            return;
          }

          const buttonKey = `${username}-kick`;
          if (state.processingButtons.has(buttonKey)) return;

          state.processingButtons.add(buttonKey);
          state.isProcessing = true;
          updateUIState();

          try {
            const res = await fetch(
              `${API_BASE}/groups/${encodeURIComponent(
                state.currentGroup
              )}/members/${encodeURIComponent(username)}`,
              {
                method: "DELETE",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ requester: state.username }),
              }
            );
            if (!res.ok) {
              const errorData = await res.json();
              throw new Error(
                errorData.error || `Failed to kick member (${res.status})`
              );
            }
            showToast(`Kicked ${sanitizeInput(username)} from group`);
            // Group member list will be updated via WebSocket group_update
          } catch (err) {
            showToast(`Failed to kick member: ${err.message}`, true);
          } finally {
            state.processingButtons.delete(buttonKey);
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function addAdmin(username) {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          if (!state.isConnected)
            return showToast("Not connected to chat", true);
          if (!state.currentGroup) return showToast("No group selected", true);
          if (
            !validateInput(
              username,
              USERNAME_REGEX,
              "addMemberUsername",
              "Invalid username"
            )
          ) {
            return;
          }

          const buttonKey = `${username}-addAdmin`;
          if (state.processingButtons.has(buttonKey)) return;

          state.processingButtons.add(buttonKey);
          state.isProcessing = true;
          updateUIState();

          try {
            const res = await fetch(
              `${API_BASE}/groups/${encodeURIComponent(
                state.currentGroup
              )}/admins`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  username: username,
                  requester: state.username,
                }),
              }
            );
            if (!res.ok) {
              const errorData = await res.json();
              throw new Error(
                errorData.error || `Failed to add admin (${res.status})`
              );
            }
            showToast(`Made ${sanitizeInput(username)} an admin`);
            // Group member list will be updated via WebSocket group_update
          } catch (err) {
            showToast(`Failed to add admin: ${err.message}`, true);
          } finally {
            state.processingButtons.delete(buttonKey);
            state.isProcessing = false;
            updateUIState();
          }
        }

        async function removeAdmin(username) {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          if (!state.isConnected)
            return showToast("Not connected to chat", true);
          if (!state.currentGroup) return showToast("No group selected", true);
          if (
            !validateInput(
              username,
              USERNAME_REGEX,
              "addMemberUsername",
              "Invalid username"
            )
          ) {
            return;
          }

          const buttonKey = `${username}-removeAdmin`;
          if (state.processingButtons.has(buttonKey)) return;

          state.processingButtons.add(buttonKey);
          state.isProcessing = true;
          updateUIState();

          try {
            const res = await fetch(
              `${API_BASE}/groups/${encodeURIComponent(
                state.currentGroup
              )}/admins/${encodeURIComponent(username)}`,
              {
                method: "DELETE",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ requester: state.username }),
              }
            );
            if (!res.ok) {
              const errorData = await res.json();
              throw new Error(
                errorData.error || `Failed to remove admin (${res.status})`
              );
            }
            showToast(`Removed admin status from ${sanitizeInput(username)}`);
            // Group member list will be updated via WebSocket group_update
          } catch (err) {
            showToast(`Failed to remove admin: ${err.message}`, true);
          } finally {
            state.processingButtons.delete(buttonKey);
            state.isProcessing = false;
            updateUIState();
          }
        }

        function updateTypingDisplay() {
          if (
            elements.isGroup.checked &&
            state.currentGroup === state.targetId
          ) {
            const activeUsers = Array.from(state.typingUsers.keys())
              .filter((sender) => state.typingUsers.get(sender).active)
              .map(sanitizeInput);
            if (activeUsers.length > 0) {
              elements.typingStatus.textContent = `${activeUsers.join(", ")} ${
                activeUsers.length > 1 ? "are" : "is"
              } typing...`;
            } else {
              elements.typingStatus.textContent = "";
            }
          } else if (
            !elements.isGroup.checked &&
            state.typingUsers.has(state.targetId)
          ) {
            const isActive = state.typingUsers.get(state.targetId).active;
            elements.typingStatus.textContent = isActive
              ? `${sanitizeInput(state.targetId)} is typing...`
              : "";
          } else {
            elements.typingStatus.textContent = "";
          }
        }

        function showTyping(sender, isTyping, groupId) {
          if (sender === state.username) return;

          console.log(
            `Processing typing: sender=${sender}, isTyping=${isTyping}, groupId=${
              groupId || "none"
            }, currentGroup=${state.currentGroup}, targetId=${
              state.targetId
            }, isGroup=${elements.isGroup.checked}`
          ); // Debug log

          const isGroupChat =
            elements.isGroup.checked &&
            groupId &&
            groupId === state.currentGroup &&
            groupId === state.targetId;
          const isDirectChat =
            !elements.isGroup.checked && !groupId && sender === state.targetId;

          if (!isGroupChat && !isDirectChat) {
            console.log("Typing message ignored: not relevant to current chat");
            return;
          }

          // Clear existing timeout if any
          if (state.typingUsers.has(sender)) {
            clearTimeout(state.typingUsers.get(sender).timeout);
          }

          if (isTyping) {
            // Set typing status with a timeout
            const timeout = setTimeout(() => {
              state.typingUsers.set(sender, {
                active: false,
                timeout: null,
              });
              updateTypingDisplay();
            }, TYPING_TIMEOUT);

            state.typingUsers.set(sender, {
              active: true,
              timeout: timeout,
            });
          } else {
            state.typingUsers.set(sender, {
              active: false,
              timeout: null,
            });
          }

          updateTypingDisplay();
        }

        function sendTypingStatus(isTyping) {
          if (!state.isConnected || !state.targetId) {
            console.log(
              "Cannot send typing status: not connected or no target"
            );
            return;
          }
          if (state.isTypingSent === isTyping) {
            console.log("Typing status unchanged, skipping send");
            return;
          }

          if (state.socket && state.socket.readyState === WebSocket.OPEN) {
            const message = {
              type: "typing",
              sender: state.username,
              status: isTyping ? "start" : "stop",
            };
            if (elements.isGroup.checked) {
              message.group_id = state.targetId;
            } else {
              message.receiver = state.targetId;
            }
            console.log("Sending typing status:", message); // Debug log
            state.socket.send(JSON.stringify(message));
            state.isTypingSent = isTyping;
          } else {
            console.log("WebSocket not open, cannot send typing status");
          }
        }

        async function sendMessage() {
          if (state.isProcessing)
            return showToast("Another action is in progress", true);
          if (!state.isConnected)
            return showToast("Not connected to chat", true);
          if (!state.targetId)
            return showToast("Select a chat target first", true);

          const content = elements.messageInput.value.trim();
          if (!content) {
            showError("messageInput", "Message cannot be empty");
            return;
          }
          if (content.length > 1000) {
            showError("messageInput", "Message cannot exceed 1000 characters");
            return;
          }
          clearError("messageInput");

          state.isProcessing = true;
          updateUIState();

          try {
            if (state.socket && state.socket.readyState === WebSocket.OPEN) {
              const message = {
                type: "message",
                sender: state.username,
                content: content,
                timestamp: new Date().toISOString(),
              };
              if (elements.isGroup.checked) {
                message.group_id = state.targetId;
              } else {
                message.receiver = state.targetId;
              }
              state.socket.send(JSON.stringify(message));
              elements.messageInput.value = "";
              if (state.isTypingSent) {
                sendTypingStatus(false);
              }
            } else {
              throw new Error("WebSocket not connected");
            }
          } catch (err) {
            showToast(`Failed to send message: ${err.message}`, true);
          } finally {
            state.isProcessing = false;
            updateUIState();
          }
        }

        // Event Listeners
        elements.messageInput.addEventListener(
          "input",
          debounce(() => {
            if (elements.messageInput.value.trim()) {
              sendTypingStatus(true);
              if (state.typingTimeout) clearTimeout(state.typingTimeout);
              state.typingTimeout = setTimeout(
                () => sendTypingStatus(false),
                3000
              );
            } else if (state.isTypingSent) {
              sendTypingStatus(false);
            }
            updateUIState();
          }, 300)
        );

        elements.targetId.addEventListener("input", () => {
          state.typingUsers.clear();
          elements.typingStatus.textContent = "";
          updateUIState();
        });

        elements.isGroup.addEventListener("change", () => {
          state.typingUsers.clear();
          elements.typingStatus.textContent = "";
          if (elements.isGroup.checked && state.targetId) {
            startChat(state.targetId, true);
          } else if (state.targetId) {
            startChat(state.targetId, false);
          }
          updateUIState();
        });

        elements.username.addEventListener("input", () => {
          clearError("username");
          updateUIState();
        });

        elements.groupName.addEventListener("input", () => {
          clearError("groupName");
          updateUIState();
        });

        elements.addMemberUsername.addEventListener("input", () => {
          clearError("addMemberUsername");
          updateUIState();
        });

        // Public Methods
        return {
          registerUser,
          loginUser,
          logoutUser,
          createGroup,
          startChat,
          joinGroup,
          sendMessage,
          addMember,
          kickMember,
          addAdmin,
          removeAdmin,
        };
      })();
    </script>
  </body>
</html>
